<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>layout editor</title>

<link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.0/dist/gridstack.min.css" rel="stylesheet" />

<style>
*{
    color-scheme: light dark;
    color:var(--defualt-text-color);
}

    :root{
        color-scheme: light dark;
        --defualt-text-color-dark: #f3f5f8;
        --button-color-dark: black; 
        --bg-color-dark:rgb(11, 11, 11);
        --gridstack-item-dark: #08011f;
        --gridstack-container-dark: #08031c;
        --editors-dark: #0b0b12;
        --shadow-dark: 0 4px 12px rgba(227, 227, 227, 0.301);

        --defualt-text-color-light: black;
        --button-color-light:#fff;
        --bg-color-light:#f3f5f8;
        --gridstack-item-light: #fafafa;
        --gridstack-container-light: #fafafa;
        --editors-light: #fff;
        --shadow-light: 0 4px 12px rgba(0,0,0,0.05); 

        --defualt-text-color: light-dark(var(--defualt-text-color-light), var(--defualt-text-color-dark));
        --button-color:light-dark(var(--button-color-light), var(--button-color-dark)); 
        --bg-color:light-dark(var(--bg-color-light), var(--bg-color-dark));
        --gridstack-item: light-dark(var(--gridstack-item-light), var(--gridstack-item-dark));
        --gridstack-container: light-dark(var(--gridstack-container-light), var(--gridstack-container-dark));
        --editors: light-dark(var(--editors-light), var(--editors-dark));
        /* default to light shadow ‚Äî override in media query for dark */
        --shadow: var(--shadow-light);
        
    }
    /* Make shadows follow the system color-scheme (so "auto" works) */
    @media (prefers-color-scheme: dark) {
      :root {
        --shadow: var(--shadow-dark);
      }
    }

  body {
     font-family: system-ui, sans-serif;
     background-color:var(--bg-color);
     margin:20px; 
    }
  h2 { 
    text-align:center; 
  }
  .toolbar { 
    display:flex; 
    gap:8px; 
    justify-content:center; 
    margin-bottom:12px; 
    flex-wrap: wrap; 
  }
  .grid-stack {
    color-scheme: light dark;
     background-color:var(--gridstack-container);
     border:2px solid #ccc; 
     border-radius:8px; 
     width:100%; 
     height:100%; 
     margin:auto; 
     max-height: 1500px !important;
    }
  .grid-stack-item-content {
    background-color: var(--gridstack-item);
      /*background:linear-gradient(180deg,#ffffff,#f1f3f9);*/ 
      border:1px solid #d0d6e2; 
      border-radius:6px; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      box-shadow:var(--shadow);
      overflow:hidden; 
    }
  button { 
    padding:8px 12px; 
    border-radius:6px; 
    border:1px solid #bbb; 
    background-color:var(--button-color);
    cursor:pointer; 
  }
  button:active {
     transform:translateY(1px); 
    }
  input { 
    width:50px; 
    padding:4px; 
    border-radius:4px; 
    border:1px solid #bbb; 
  }
  /* Editors layout: side-by-side with gap */
  #editors { 
    display: flex; 
    gap: 12px; 
    margin-top: 20px; 
    align-items: stretch; 
  }
  /* child panels inside #editors */
  #editors > .editors {
    flex: 1 1 0%;
    min-width: 0;            /* allow flex children to shrink properly */
    height: 300px;
    overflow: hidden;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 6px;
    box-sizing: border-box;
    background: var(--editors)
  }
  /* Monaco containers take full height of their panel */
  #cssEditor, #htmlEditor { height: 100%; }
  
  /* small style for the custom context menu items to match UI */
  #custom-context-menu button { background: transparent; }
  #custom-context-menu button:hover { background: rgba(0,0,0,0.03); }
  .theme-toggle{text-align: center;}
  .theme-toggle button {
    padding: 5px 5px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;

    align-items: center;
    gap: 8px;
    transition: background 0.3s, color 0.3s;
  }

  .theme-toggle button:hover {
    background: #ddd;
  }

  .theme-toggle button.active {
    background: #007BFF;
    color: white;
  }

  .icon-light::before { content: "‚òÄÔ∏è"; }
  .icon-dark::before { content: "üåô"; }
  .icon-auto::before { content: "‚ö°"; }
</style>
</head>
<body>
<h2>css ux/ui layout designer</h2>


<div class="theme-toggle">
  <button id="lightBtn" class="icon-light"></button>
  <button id="darkBtn" class="icon-dark"></button>
  <button id="autoBtn" class="icon-auto"></button>
</div>

<br>

<div class="toolbar">
  <button id="add">Add widget</button>
  <button id="export">Export CSS</button>
</div>

<div id="container">
    <div class="grid-stack"></div>
</div>

<div id="editors" class="editors">
    css:
    <div id="cssEditor" class="editors"></div>
    html:
    <div id="htmlEditor" class="editors"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.0/dist/gridstack-all.js"></script>
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>

<script>
let CONFIG = { cols: 12, rows: 10, cellHeight: 60, gap: 2 };
let widgetCounter = 0;
let monacoInstances = {};
let grid;
let cssMonaco;

  const buttons = document.querySelectorAll('.theme-toggle button');
  buttons[2].classList.add('active'); // default to auto
  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      buttons.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    });
  });

// Initialize the grid
function initGrid() {
  if(document.querySelector('.grid-stack')==null){document.getElementById('container').innerHTML='<div class="grid-stack"></div>';}
  const container = document.querySelector('.grid-stack');
  grid = GridStack.init({
    column: CONFIG.cols,
    cellHeight: CONFIG.cellHeight,
    disableOneColumnMode: true,
    float: false,
    minRow: CONFIG.rows,
    margin: CONFIG.gap
  }, container);
}


function addWidget(content, opts) {
  widgetCounter++;
  const id = `item-${widgetCounter}`;
  // Place data-gs-id on the outer container so export CSS can reference it via n.el.dataset.gsId
  const html = `<div class="grid-stack-item" data-gs-id="${id}"><div class="grid-stack-item-content">${content}</div></div>`;
  grid.addWidget(html, opts);
  return id;
}


// Export CSS to Monaco editor
function exportCSS() {
  let css = `.container { display: grid; grid-template-columns: repeat(${CONFIG.cols}, 1fr); grid-auto-rows: ${CONFIG.cellHeight}px; gap: ${CONFIG.gap}px; }\n`;
  // grid.engine.nodes contains the node objects
  if (grid && grid.engine && Array.isArray(grid.engine.nodes)) {
    grid.engine.nodes.forEach(n => {
      const id = n.el?.dataset?.gsId || `unknown-${n.id || n.el?.id || Math.random().toString(36).slice(2,8)}`;
      css += `.${id} { grid-column: ${n.x + 1} / span ${n.w}; grid-row: ${n.y + 1} / span ${n.h}; }\n`;
    });
  }
  if(cssMonaco) cssMonaco.setValue(css);
  exportHTML()
}
function exportHTML() {
  let css = `.container { display: grid; grid-template-columns: repeat(${CONFIG.cols}, 1fr); grid-auto-rows: ${CONFIG.cellHeight}px; gap: ${CONFIG.gap}px; }\n`;
  let html = `<div class='container'>\n`
  // grid.engine.nodes contains the node objects
  if (grid && grid.engine && Array.isArray(grid.engine.nodes)) {
    grid.engine.nodes.forEach(n => {
      const id = n.el?.dataset?.gsId || `unknown-${n.id || n.el?.id || Math.random().toString(36).slice(2,8)}`;
      // Prefer the live innerHTML of the widget content so edits are preserved
      const contentEl = n.el && n.el.querySelector ? n.el.querySelector('.grid-stack-item-content') : null;
      const content = contentEl ? contentEl.innerHTML.trim() : id;
      // If content includes newlines/leading/trailing whitespace, keep it tidy
      html += `  <div class='${id}'>${content}</div>\n`;
    });
    html+='</div>'
  }
  if(htmlMonaco) htmlMonaco.setValue(html);
}

// DOM ready
document.addEventListener('DOMContentLoaded', () => {
  initGrid();

  // Seed widgets
  addWidget('A', { x:0, y:0, w:3, h:2 });
  addWidget('B', { x:3, y:0, w:4, h:3 });
  addWidget('C', { x:0, y:3, w:2, h:2 });

  // Button events
  document.getElementById('add').addEventListener('click', () => addWidget('empty', { w:2, h:2 }));



  document.getElementById('export').addEventListener('click', exportCSS);
  
  // Initialize CSS Monaco editor
  require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' }});
  require(['vs/editor/editor.main'], () => {
    cssMonaco = monaco.editor.create(document.getElementById('cssEditor'), {
      value: '',
      language: 'css',
      theme: 'vs-dark',
      automaticLayout: true,
      readOnly: true
    });
    htmlMonaco = monaco.editor.create(document.getElementById('htmlEditor'), {
      value: '',
      language: 'html',
      theme: 'vs-dark',
      automaticLayout: true,
      readOnly: true
    });
    // Do NOT set Monaco theme here. We'll apply the saved/applicable theme after editors are created
    // so user preference isn't accidentally overridden.
    console.log('Monaco initialized');

    // Apply saved theme (cookies) now that Monaco is ready
    applySavedTheme();
  });





  // --------- Custom Context Menu Integration ---------

  // Create context menu element
  const contextMenu = document.createElement('div');
  contextMenu.id = 'custom-context-menu';
  contextMenu.style.cssText = `
      position: fixed;
      background: grey;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 10000;
      display: none;
      min-width: 140px;
      overflow: hidden;
  `;
  contextMenu.innerHTML = `
      <button data-action="edit" style="display:block; width:100%; padding: 8px 12px; border:none; background:none; text-align:left; cursor:pointer;">‚úèÔ∏è Edit</button>
      <button data-action="delete" style="display:block; width:100%; padding: 8px 12px; border:none; background:none; text-align:left; color:red; cursor:pointer;">üóëÔ∏è Delete</button>
  `;
  document.body.appendChild(contextMenu);

  let activeWidgetContent = null; // Stores the .grid-stack-item-content element

  // Function to stop editing on blur
  function stopEditing(e) {
      const target = e.target;
      // Check if the element is currently editable
      if (target.getAttribute && target.getAttribute('contenteditable') === 'true') {
          // Disable editing
          target.setAttribute('contenteditable', 'false');
          // Remove the blur listener itself after editing stops to avoid memory leaks
          target.removeEventListener('blur', stopEditing);
          // Re-enable GridStack dragging if possible
          const gsItem = target.closest('.grid-stack-item');
          if (gsItem && grid && typeof grid.enableMove === 'function') {
              try { grid.enableMove(gsItem, true); } catch (err) { /* ignore if API differs */ }
          } else if (gsItem && grid && typeof grid.movable === 'function') {
              // fallback if API is named differently
              try { grid.movable(gsItem, true); } catch (err) { /* ignore */ }
          }
          // Update exported HTML to include the edited content
          try { exportHTML(); } catch (err) { /* ignore if exportHTML not yet defined */ }
      }
  }

  // 1. Show menu on right-click over a widget
  document.querySelector('.grid-stack').addEventListener('contextmenu', (e) => {
      const itemContent = e.target.closest('.grid-stack-item-content');

      if (itemContent) {
          e.preventDefault(); // Prevent default browser context menu
          activeWidgetContent = itemContent;
          
          // If editing is active, stop it before showing the menu
          if (activeWidgetContent.getAttribute('contenteditable') === 'true') {
               activeWidgetContent.setAttribute('contenteditable', 'false');
               activeWidgetContent.blur(); // Remove focus
          }

          // Position and show the menu (keeping it inside viewport)
          const margin = 8;
          let left = e.clientX;
          let top = e.clientY;
          // ensure menu doesn't overflow right/bottom
          const rect = contextMenu.getBoundingClientRect();
          const viewportW = window.innerWidth;
          const viewportH = window.innerHeight;
          // temporarily show to measure height if hidden (small trick)
          contextMenu.style.display = 'block';
          const menuW = contextMenu.offsetWidth;
          const menuH = contextMenu.offsetHeight;
          if (left + menuW + margin > viewportW) left = viewportW - menuW - margin;
          if (top + menuH + margin > viewportH) top = viewportH - menuH - margin;
          contextMenu.style.left = `${left}px`;
          contextMenu.style.top = `${top}px`;
          contextMenu.style.display = 'block';
      } else {
          // If clicking outside a widget content, just hide the menu
          contextMenu.style.display = 'none';
      }
  });

  // 2. Hide menu on any regular click (but allow clicks inside context menu to be handled)
  document.addEventListener('click', (ev) => {
      // if click is inside the menu, don't hide here (menu's click handler will handle)
      if (ev.target.closest && ev.target.closest('#custom-context-menu')) return;
      contextMenu.style.display = 'none';
  });

  // 3. Handle menu actions
  contextMenu.addEventListener('click', (e) => {
      const action = e.target.getAttribute('data-action');

      if (!activeWidgetContent) {
        contextMenu.style.display = 'none';
        return;
      }

      if (action === 'edit') {
          // Enable editing
          activeWidgetContent.setAttribute('contenteditable', 'true');
          activeWidgetContent.focus(); // Set focus to start editing
          
          // Add the blur listener so focus-out stops editing
          activeWidgetContent.addEventListener('blur', stopEditing);
          
          // Optional: Disable GridStack dragging while editing text
          const gsItem = activeWidgetContent.closest('.grid-stack-item');
          if (gsItem && grid && typeof grid.enableMove === 'function') {
              try { grid.enableMove(gsItem, false); } catch (err) { /* ignore */ }
          } else if (gsItem && grid && typeof grid.movable === 'function') {
              try { grid.movable(gsItem, false); } catch (err) { /* ignore */ }
          }

      } else if (action === 'delete') {
          // Delete the widget
          const widgetEl = activeWidgetContent.closest('.grid-stack-item');
          if (widgetEl && grid && typeof grid.removeWidget === 'function') {
              try { grid.removeWidget(widgetEl); } catch (err) { 
                  // fallback: remove element from DOM if grid API fails
                  widgetEl.remove();
              }
          } else if (widgetEl) {
              widgetEl.remove();
          }
      }

      activeWidgetContent = null; // Clear the reference
      contextMenu.style.display = 'none'; // Hide the menu
  });
  // --------- End Context Menu Integration ---------

  // Theme toggle functionality
  const lightBtn = document.getElementById('lightBtn');
  const darkBtn = document.getElementById('darkBtn');
  const autoBtn = document.getElementById('autoBtn');
  
  // Cookie helpers (persist theme preference across page reloads)
  function setCookie(name, value, days) {
    const d = new Date();
    d.setTime(d.getTime() + (days*24*60*60*1000));
    document.cookie = `${name}=${encodeURIComponent(value)};expires=${d.toUTCString()};path=/`;
  }
  function getCookie(name) {
    const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return v ? decodeURIComponent(v.pop()) : null;
  }

  // Apply saved theme (called after Monaco is initialized)
  function applySavedTheme() {
    const saved = getCookie('preferred-theme');
    if (saved) {
      setTheme(saved);
    } else {
      setTheme('auto');
    }
  }
  
  function setTheme(theme) {
    const root = document.documentElement;
    buttons.forEach(b => b.classList.remove('active'));
    // persist preference in cookie for 1 year
    setCookie('preferred-theme', theme, 365);

    if (theme === 'light') {
      root.style.setProperty('--defualt-text-color', 'var(--defualt-text-color-light)');
      root.style.setProperty('--button-color', 'var(--button-color-light)');
      root.style.setProperty('--bg-color', 'var(--bg-color-light)');
      root.style.setProperty('--gridstack-item', 'var(--gridstack-item-light)');
      root.style.setProperty('--gridstack-container', 'var(--gridstack-container-light)');
      root.style.setProperty('--editors', 'var(--editors-light)');
      root.style.setProperty('--shadow', 'var(--shadow-light)');

      lightBtn.classList.add('active');
      if (monaco?.editor) monaco.editor.setTheme('vs-light');
    } else if (theme === 'dark') {
      root.style.setProperty('--defualt-text-color', 'var(--defualt-text-color-dark)');
      root.style.setProperty('--button-color', 'var(--button-color-dark)');
      root.style.setProperty('--bg-color', 'var(--bg-color-dark)');
      root.style.setProperty('--gridstack-item', 'var(--gridstack-item-dark)');
      root.style.setProperty('--gridstack-container', 'var(--gridstack-container-dark)');
      root.style.setProperty('--editors', 'var(--editors-dark)');
      root.style.setProperty('--shadow', 'var(--shadow-dark)');

      darkBtn.classList.add('active');
      if (monaco?.editor) monaco.editor.setTheme('vs-dark');
    } else {
      // Auto: remove any inline --shadow so CSS media query controls it
      root.style.setProperty('--defualt-text-color', 'light-dark(var(--defualt-text-color-light), var(--defualt-text-color-dark))');
      root.style.setProperty('--button-color', 'light-dark(var(--button-color-light), var(--button-color-dark))');
      root.style.setProperty('--bg-color', 'light-dark(var(--bg-color-light), var(--bg-color-dark))');
      root.style.setProperty('--gridstack-item', 'light-dark(var(--gridstack-item-light), var(--gridstack-item-dark))');
      root.style.setProperty('--gridstack-container', 'light-dark(var(--gridstack-container-light), var(--gridstack-container-dark))');
      root.style.setProperty('--editors', 'light-dark(var(--editors-light), var(--editors-dark))');

      // IMPORTANT: let the CSS @media (prefers-color-scheme) control --shadow
      root.style.removeProperty('--shadow');

      autoBtn.classList.add('active');
      const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      if (monaco?.editor) monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs-light');
    }
  }
  
  // Theme button click handlers
  lightBtn.addEventListener('click', () => setTheme('light'));
  darkBtn.addEventListener('click', () => setTheme('dark'));
  autoBtn.addEventListener('click', () => setTheme('auto'));

  // Note: theme application happens in applySavedTheme() which is called after Monaco init.
  // If Monaco isn't used, call applySavedTheme immediately:
  if (typeof monaco === 'undefined') applySavedTheme();
  
  // Listen for system theme changes in auto mode
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    if (autoBtn.classList.contains('active')) {
      if (monaco?.editor) {
        monaco.editor.setTheme(e.matches ? 'vs-dark' : 'vs-light');
      }
    }
  });
});
</script>
</body>
</html>
