<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gridstack + Monaco ‚Üí Pure CSS Export (with Context Menu)</title>

<link href="https://cdn.jsdelivr.net/npm/gridstack@9.2.0/dist/gridstack.min.css" rel="stylesheet" />

<style>*{color-scheme: light dark;color:light-dark(black,#f3f5f8);}
  body { font-family: system-ui, sans-serif; background-color:light-dark(#f3f5f8,rgb(31, 31, 31)f8); margin:20px; }
  h2 { text-align:center; }
  .toolbar { display:flex; gap:8px; justify-content:center; margin-bottom:12px; flex-wrap: wrap; }
  .grid-stack {color-scheme: light dark; background-color:light-dark(#fafafa,#160F30); border:2px solid #ccc; border-radius:8px; width:100%; height:100%; margin:auto; max-height: 1500px !important;}
  .grid-stack-item-content {background-color: light-dark(#fafafa,#08011f);  /*background:linear-gradient(180deg,#ffffff,#f1f3f9);*/ border:1px solid #d0d6e2; border-radius:6px; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 12px rgba(0,0,0,0.05); overflow:hidden; }
  button { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background-color:light-dark(#fff, black); cursor:pointer; }
  button:active { transform:translateY(1px); }
  input { width:50px; padding:4px; border-radius:4px; border:1px solid #bbb; }
  /* Editors layout: side-by-side with gap */
  #editors { display: flex; gap: 12px; margin-top: 20px; align-items: stretch; }
  /* child panels inside #editors */
  #editors > .editors {
    flex: 1 1 0%;
    min-width: 0;            /* allow flex children to shrink properly */
    height: 300px;
    overflow: hidden;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 6px;
    box-sizing: border-box;
    background: light-dark(#fff, #0b0b12);
  }
  /* Monaco containers take full height of their panel */
  #cssEditor, #htmlEditor { height: 100%; }
  
  /* small style for the custom context menu items to match UI */
  #custom-context-menu button { background: transparent; }
  #custom-context-menu button:hover { background: rgba(0,0,0,0.03); }
</style>
</head>
<body>
<h2>üß± Gridstack + Monaco ‚Üí Export Pure CSS (with Context Menu)</h2>

<div class="toolbar">
  <button id="add">Add widget</button>
  <button id="addMonaco">Add Monaco</button>
  <button id="setGridSize">Set Grid Size</button>
  <button id="export">Export CSS</button>
</div>

<div id="container"><div class="grid-stack"></div></div>
<div id="editors" class="editors">css:<div id="cssEditor" class="editors"></div>html:<div id="htmlEditor" class="editors"></div></div>

<script src="https://cdn.jsdelivr.net/npm/gridstack@9.2.0/dist/gridstack-all.js"></script>
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs/loader.js"></script>

<script>
let CONFIG = { cols: 12, rows: 10, cellHeight: 60, gap: 2 };
let widgetCounter = 0;
let monacoInstances = {};
let grid;
let cssMonaco;

// Initialize the grid
function initGrid() {
  if(document.querySelector('.grid-stack')==null){document.getElementById('container').innerHTML='<div class="grid-stack"></div>';}
  const container = document.querySelector('.grid-stack');
  grid = GridStack.init({
    column: CONFIG.cols,
    cellHeight: CONFIG.cellHeight,
    disableOneColumnMode: true,
    float: false,
    minRow: CONFIG.rows,
    margin: CONFIG.gap
  }, container);
}


function addWidget(content, opts) {
  widgetCounter++;
  const id = `item-${widgetCounter}`;
  // Place data-gs-id on the outer container so export CSS can reference it via n.el.dataset.gsId
  const html = `<div class="grid-stack-item" data-gs-id="${id}"><div class="grid-stack-item-content">${content}</div></div>`;
  grid.addWidget(html, opts);
  return id;
}

// Add Monaco widget
function addMonacoWidget() {
  widgetCounter++;
  const id = `item-${widgetCounter}`;
  const html = `<div class="grid-stack-item" data-gs-id="${id}"><div class="grid-stack-item-content"><div id="monaco-${id}" class="monaco-editor" style="width:100%;height:100%;"></div></div></div>`;
  grid.addWidget(html, { w: 6, h: 4 });
  require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' }});
  require(['vs/editor/editor.main'], () => {
    monacoInstances[id] = monaco.editor.create(document.getElementById(`monaco-${id}`), {
      value: '// Your code here',
      language: 'javascript',
      theme: 'vs-dark',
      automaticLayout: true
    });
  });
}

// Export CSS to Monaco editor
function exportCSS() {
  let css = `.grid-container { display: grid; grid-template-columns: repeat(${CONFIG.cols}, 1fr); grid-auto-rows: ${CONFIG.cellHeight}px; gap: ${CONFIG.gap}px; }\n`;
  // grid.engine.nodes contains the node objects
  if (grid && grid.engine && Array.isArray(grid.engine.nodes)) {
    grid.engine.nodes.forEach(n => {
      const id = n.el?.dataset?.gsId || `unknown-${n.id || n.el?.id || Math.random().toString(36).slice(2,8)}`;
      css += `.item-${id} { grid-column: ${n.x + 1} / span ${n.w}; grid-row: ${n.y + 1} / span ${n.h}; }\n`;
    });
  }
  if(cssMonaco) cssMonaco.setValue(css);
}

// DOM ready
document.addEventListener('DOMContentLoaded', () => {
  initGrid();

  // Seed widgets
  addWidget('A', { x:0, y:0, w:3, h:2 });
  addWidget('B', { x:3, y:0, w:4, h:3 });
  addWidget('C', { x:0, y:3, w:2, h:2 });

  // Button events
  document.getElementById('add').addEventListener('click', () => addWidget('empty', { w:2, h:2 }));




  document.getElementById('export').addEventListener('click', exportCSS);
  
  // Initialize CSS Monaco editor
  require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.49.0/min/vs' }});
  require(['vs/editor/editor.main'], () => {
    cssMonaco = monaco.editor.create(document.getElementById('cssEditor'), {
      value: '',
      language: 'css',
      theme: 'vs-dark',
      automaticLayout: true,
      readOnly: true
    });
    htmlMonaco = monaco.editor.create(document.getElementById('htmlEditor'), {
      value: '',
      language: 'html',
      theme: 'vs-dark',
      automaticLayout: true,
      readOnly: true
    });
    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    console.log('Applying theme:', isDark ? 'dark' : 'light');
    monaco.editor.setTheme(isDark ? 'vs-dark' : 'vs-light');

    //window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
});





  // --------- Custom Context Menu Integration ---------

  // Create context menu element
  const contextMenu = document.createElement('div');
  contextMenu.id = 'custom-context-menu';
  contextMenu.style.cssText = `
      position: fixed;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 10000;
      display: none;
      min-width: 140px;
      overflow: hidden;
  `;
  contextMenu.innerHTML = `
      <button data-action="edit" style="display:block; width:100%; padding: 8px 12px; border:none; background:none; text-align:left; cursor:pointer;">‚úèÔ∏è Edit</button>
      <button data-action="delete" style="display:block; width:100%; padding: 8px 12px; border:none; background:none; text-align:left; color:red; cursor:pointer;">üóëÔ∏è Delete</button>
  `;
  document.body.appendChild(contextMenu);

  let activeWidgetContent = null; // Stores the .grid-stack-item-content element

  // Function to stop editing on blur
  function stopEditing(e) {
      const target = e.target;
      // Check if the element is currently editable
      if (target.getAttribute && target.getAttribute('contenteditable') === 'true') {
          // Disable editing
          target.setAttribute('contenteditable', 'false');
          // Remove the blur listener itself after editing stops to avoid memory leaks
          target.removeEventListener('blur', stopEditing);
          // Re-enable GridStack dragging if possible
          const gsItem = target.closest('.grid-stack-item');
          if (gsItem && grid && typeof grid.enableMove === 'function') {
              try { grid.enableMove(gsItem, true); } catch (err) { /* ignore if API differs */ }
          } else if (gsItem && grid && typeof grid.movable === 'function') {
              // fallback if API is named differently
              try { grid.movable(gsItem, true); } catch (err) { /* ignore */ }
          }
      }
  }

  // 1. Show menu on right-click over a widget
  document.querySelector('.grid-stack').addEventListener('contextmenu', (e) => {
      const itemContent = e.target.closest('.grid-stack-item-content');

      if (itemContent) {
          e.preventDefault(); // Prevent default browser context menu
          activeWidgetContent = itemContent;
          
          // If editing is active, stop it before showing the menu
          if (activeWidgetContent.getAttribute('contenteditable') === 'true') {
               activeWidgetContent.setAttribute('contenteditable', 'false');
               activeWidgetContent.blur(); // Remove focus
          }

          // Position and show the menu (keeping it inside viewport)
          const margin = 8;
          let left = e.clientX;
          let top = e.clientY;
          // ensure menu doesn't overflow right/bottom
          const rect = contextMenu.getBoundingClientRect();
          const viewportW = window.innerWidth;
          const viewportH = window.innerHeight;
          // temporarily show to measure height if hidden (small trick)
          contextMenu.style.display = 'block';
          const menuW = contextMenu.offsetWidth;
          const menuH = contextMenu.offsetHeight;
          if (left + menuW + margin > viewportW) left = viewportW - menuW - margin;
          if (top + menuH + margin > viewportH) top = viewportH - menuH - margin;
          contextMenu.style.left = `${left}px`;
          contextMenu.style.top = `${top}px`;
          contextMenu.style.display = 'block';
      } else {
          // If clicking outside a widget content, just hide the menu
          contextMenu.style.display = 'none';
      }
  });

  // 2. Hide menu on any regular click (but allow clicks inside context menu to be handled)
  document.addEventListener('click', (ev) => {
      // if click is inside the menu, don't hide here (menu's click handler will handle)
      if (ev.target.closest && ev.target.closest('#custom-context-menu')) return;
      contextMenu.style.display = 'none';
  });

  // 3. Handle menu actions
  contextMenu.addEventListener('click', (e) => {
      const action = e.target.getAttribute('data-action');

      if (!activeWidgetContent) {
        contextMenu.style.display = 'none';
        return;
      }

      if (action === 'edit') {
          // Enable editing
          activeWidgetContent.setAttribute('contenteditable', 'true');
          activeWidgetContent.focus(); // Set focus to start editing
          
          // Add the blur listener so focus-out stops editing
          activeWidgetContent.addEventListener('blur', stopEditing);
          
          // Optional: Disable GridStack dragging while editing text
          const gsItem = activeWidgetContent.closest('.grid-stack-item');
          if (gsItem && grid && typeof grid.enableMove === 'function') {
              try { grid.enableMove(gsItem, false); } catch (err) { /* ignore */ }
          } else if (gsItem && grid && typeof grid.movable === 'function') {
              try { grid.movable(gsItem, false); } catch (err) { /* ignore */ }
          }

      } else if (action === 'delete') {
          // Delete the widget
          const widgetEl = activeWidgetContent.closest('.grid-stack-item');
          if (widgetEl && grid && typeof grid.removeWidget === 'function') {
              try { grid.removeWidget(widgetEl); } catch (err) { 
                  // fallback: remove element from DOM if grid API fails
                  widgetEl.remove();
              }
          } else if (widgetEl) {
              widgetEl.remove();
          }
      }

      activeWidgetContent = null; // Clear the reference
      contextMenu.style.display = 'none'; // Hide the menu
  });
  // --------- End Context Menu Integration ---------
});
</script>
</body>
</html>
